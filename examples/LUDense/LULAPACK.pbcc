#ifndef LULAPACK_PBCC
#define LULAPACK_PBCC

#define INDEX2D(i0, i1, s0) ((i1) * (s0) + (i0))

%{
extern "C" void dgetrf_(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info);
extern "C" void sgetrf_(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info);

void getrf_wrap(const int *m, const int *n, double *A, const int *lda, int *ipiv, int *info) {
  dgetrf_(m, n, A, lda, ipiv, info);
}
void getrf_wrap(const int *m, const int *n, float *A, const int *lda, int *ipiv, int *info) {
  sgetrf_(m, n, A, lda, ipiv, info);
}
%}

transform LULAPACK
from IN[n,n]
to OUT[n,n], P[n]
{
    to (OUT out, P p)
    from (IN in)
    {
        // call LAPACK

        const int m = n, lda = n;
        int info = 0, *ipiv = NULL;
        ElementT *A = NULL;

        A = new ElementT[n * n];
        ipiv = new int[n];
        if (!A || !ipiv) {
            printf("Error allocating memory!\n");
            exit(-1);
        }

        // pack input
        int i, j;
        for (i = 0; i < n; ++i) {
            for (j = 0; j < n; ++j) {
                // PetaBricks - first index is column, second is row
                A[INDEX2D(i, j, n)] = in.cell(j, i);
            }
        }

        getrf_wrap(&m, &n, A, &lda, ipiv, &info);
        if (info) {
            printf("LAPACK error in call to dppsv: info = %d\n", info);
            exit(-1);
        }

        // unpack output
        for (i = 0; i < n; ++i) {
            for (j = 0; j < n; ++j) {
                out.cell(i, j) = A[INDEX2D(j, i, n)];
            }
        }
        for (i = 0; i < n; ++i) {
            p.cell(i) = ipiv[i];
        }

        delete [] ipiv;
        delete [] A;
    }
}

#endif // LULAPACK_PBCC
