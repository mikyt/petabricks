#ifndef LUBASE_PBCC
#define LUBASE_PBCC

#include "../simple/macros.h"
#include "../simple/copy.pbcc"
#include "../simple/reduce.pbcc"
#include "../trisolve/TriSolveLL.pbcc"
#include "../multiply/multiplyAdd.pbcc"
#include "DGER.pbcc"

transform Swap2D
to A[n,m], B[n,m]
{
    to (A.cell(j, i) a, B.cell(j, i) b) from ()
    {
        ElementT t;
        t = a;
        a = b;
        b = t;
    }
}

transform Scale2D
from ALPHA
to A[n,m]
{
    to (A.cell(j, i) a) from (ALPHA alpha)
    {
        a *= alpha;
    }
}

// left looking
transform LUBaseLL
to A[n,m], P[m]
{
    to (A a, P p) from ()
    {
        int j;
        ElementT iMax, jMax, valMax;

        for (j = 0; j < MIN(m,n); ++j) {

            // lazy update of all values in current column
            if (j > 0) {
                // update values above diagonal
                TriSolveLLInPlace(a.region(j, 0, j+1, j), 1,
                                  a.region(0, 0, j  , j));

                // update values on and below diagonal
                MatrixMultiplyAdd(a.region(j, j, j+1, m), -1.0,
                                  a.region(0, j, j  , m),
                                  a.region(j, 0, j+1, j), 1.0);
            }

            if (j == m - 1) {
                p.cell(j) = j;
            } else {
                // find the largest value in jth column
                ReduceAMax2D(jMax, iMax, valMax, a.region(j, j, j+1, m));
                iMax += j;

                // save swapped row index in pout
                p.cell(j) = iMax;

                // swap pivot row into current row
                if (iMax != j) {
                    Swap2D(a.region(0, j   , n, j    + 1),
                           a.region(0, iMax, n, iMax + 1));
                }

                // scale values below diagonal
                Scale2D(a.region(j, j+1, j+1, m), 1.0 / a.cell(j, j));
            }
        }

        // solve for remainder of U matrix
        if (n > m) {
            TriSolveLLInPlace(a.region(m, 0, n, m), 1,
                              a.region(0, 0, m, m));
        }

        // no swaps for rest of array
        for (j = MIN(m,n); j < m; ++j) {
            p.cell(j) = j;
        }
    }
}

// right looking
transform LUBaseRL
to A[n,m], P[m]
{
    to (A a, P p) from ()
    {
        int j;
        ElementT iMax, jMax, valMax;

        // for each column in square part of matrix
        for (j = 0; j < MIN(m, n); ++j) {
            if (j == m - 1) {
                p.cell(j) = j;
            } else {
                // find the largest value in jth column on/below diagonal
                ReduceAMax2D(jMax, iMax, valMax, a.region(j, j, j+1, m));
                iMax += j;

                // save swapped row index in pout
                p.cell(j) = iMax;

                // swap pivot row into current row
                if (iMax != j) {
                    Swap2D(a.region(0, j   , n, j    + 1),
                           a.region(0, iMax, n, iMax + 1));
                }

                // scale current column and update trailing submatrix
                Scale2D(a.region(j, j+1, j+1, m), 1.0 / a.cell(j, j));

                if (j < n - 1) {
                    // rank 1 trailing matrix update
                    DGER(a.region(j+1, j+1, n  , m  ), -1.0,
                         a.region(j  , j+1, j+1, m  ),
                         a.region(j+1, j  , n  , j+1));
                }
            }
        }

        // no swaps for rest of array
        for (j = MIN(m,n); j < m; ++j) {
            p.cell(j) = j;
        }
    }
}

transform LUBaseInPlace
to A[n,m], P[m]
{
   to (A a, P p) from ()
   {
        LUBaseLL(a, p);
   }

   to (A a, P p) from ()
   {
        LUBaseRL(a, p);
   }
}

transform LUBase
from IN[n,m]
to OUT[n,m], P[m]
{
   to (OUT out, P p) from (IN in)
   {
       Copy2D(out, in);
       LUBaseInPlace(out, p);
   }
}

#endif // LUBASE_PBCC
