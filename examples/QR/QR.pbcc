#ifndef QR_PBCC
#define QR_PBCC

#include "../simple/macros.h"
#include "../simple/copy.pbcc"
#include "../simple/norm.pbcc"
#include "../simple/scale.pbcc"
#include "../multiply/multiply.pbcc"
#include "../multiply/triMultiply.pbcc"
#include "../kernel/utils.pbcc"
#include "QRLAPACK.pbcc"

transform Init1D
from VALUE
to A[n]
{
    to (A.cell(i) a) from (VALUE val)
    {
        a = val;
    }
}

transform Init2D
from VALUE
to A[n,m]
{
    to (A.cell(j,i) a) from (VALUE val)
    {
        a = val;
    }
}

// compute actual Q and R matrices from the LAPACK representation generated
// by QRR
transform QRRConvert
from TAU[n]
to Q[n,m], R[n,m]
{
    to (Q q, R r) from (TAU tau)
    {
        IndexT i, j, p = MIN(m,n);
        MatrixRegion2D q1, q2, r1, r2;
        ConstMatrixRegion1D tau1;

        r1 = r.region(0,0,n,p);
        r2 = r.region(0,p,n,m);
        q1 = q.region(0,0,p,m);
        q2 = q.region(p,0,n,m);
        tau1 = tau.region(0,p);

        // copy R
        Copy2D(r1, q.region(0,0,n,p));
        for (i = 1; i < p; ++i) {
            for (j = 0; j < i; ++j) {
                r.cell(j, i) = 0;
            }
        }
        Init2D(r2, 0);

        // compute Q
        QRRConvertLAPACK(q1, q1, tau1);
        Init2D(q2, 0);
    }

    // TODO: implement native Petabricks version
}

// base version, similar to DGEQR2
transform QRRBase
to A[n,m], TAU[n]
{
    // right-looking
    to (A a, TAU tau) from ()
    {
        IndexT i;
        ElementT alpha, beta, xnorm;
        MatrixRegion2D v, a2, work, w2;
        work = MatrixRegion2D::allocate(1, n);
        for (i = 0; i < n; ++i) {

            // if last row, we're done
            if (i >= m-1) {
                tau.cell(i) = 0;
                continue;
            }

            Norm1D(xnorm, a.column(i).region(i+1, m), 2.0);
            if (xnorm == 0.0) {
                tau.cell(i) = 0;
                continue;
            }

            // compute reflector
            alpha = a.cell(i, i);
            beta = sqrt(alpha * alpha + xnorm * xnorm);
            beta = alpha > 0 ? -beta : beta;
            tau.cell(i) = (beta - alpha) / beta;
            Scale2D(a.region(i, i+1, i+1, m), 1.0 / (alpha - beta));

            // if last column, we're done
            if (i >= n-1) {
                a.cell(i, i) = beta;
                break;
            }

            v  = a.region(i  , i, i+1, m);
            a2 = a.region(i+1, i, n  , m);
            w2 = work.region(0, i+1, 1, n);

            // apply reflector to trailing matrix
            a.cell(i, i) = 1;
            MatrixMultiply(w2, a2.transposed(), v);
            MatrixMultiplyAdd(a2, -tau.cell(i), v, w2.transposed(), 1.0);
            a.cell(i, i) = beta;
        }
    }

    // left-looking
    to (A a, TAU tau) from ()
    {
        IndexT i, p, minmn = MIN(m,n);
        ElementT alpha, beta, xnorm;
        MatrixRegion1D tau1;
        MatrixRegion2D a1, a2, t1, t;
        t = MatrixRegion2D::allocate(minmn, minmn);
        for (i = 0; i < n; ++i) {

            // lazy update of this column
            if (i > 0) {
                p = MIN(i,m);
                a1 = a.region(0, 0, p, m);
                a2 = a.region(i, 0, i+1, m);
                t1 = t.region(0, 0, p, p);
                tau1 = tau.region(0, p);

                QRRTriFact(t1, a1, tau1);
                QRRMult(a2, 0, a1, t1.transposed());
            }

            // if last row, we're done
            if (i >= m-1) {
                tau.cell(i) = 0;
                continue;
            }

            Norm1D(xnorm, a.column(i).region(i+1, m), 2.0);
            if (xnorm == 0.0) {
                tau.cell(i) = 0;
                continue;
            }

            // compute reflector
            alpha = a.cell(i, i);
            beta = sqrt(alpha * alpha + xnorm * xnorm);
            beta = alpha > 0 ? -beta : beta;
            tau.cell(i) = (beta - alpha) / beta;
            Scale2D(a.region(i, i+1, i+1, m), 1.0 / (alpha - beta));
            a.cell(i, i) = beta;
        }
    }

    // TODO: write serial versions

    // call LAPACK
    to (A a, TAU tau) from ()
    {
        QRRLAPACK(a, tau, a);
    }
}

// compute triangular factor T from block reflector matrix V
// similar to DLARFT (V is forward, column storage; T is upper triangular))
transform QRRTriFact
from TAU[k]
to T[k,k], V[k,m]
{
    to (T t, V v) from (TAU tau)
    {
        IndexT i;
        for (i = 0; i < k; ++i) {
            if (tau.cell(i) == 0) {
                Init2D(t.region(i, 0, i+1, i+1), 0);
                continue;
            }
            if (i > 0) {
                ElementT vii = v.cell(i, i);
                v.cell(i, i) = 1;
                MatrixMultiplyAdd(t.region(i, 0, i+1, i), -tau.cell(i),
                                  v.region(0, i, i  , m).transposed(),
                                  v.region(i, i, i+1, m), 0.0);
                v.cell(i, i) = vii;
                TriMatrixMultiplyInPlace(t.region(i, 0, i+1, i), 1, 0,
                                         t.region(0, 0, i  , i));
            }
            t.cell(i, i) = tau.cell(i);
        }
    }

    // serial version
    to (T t, V v) from (TAU tau)
    {
        IndexT i, j, l;
        ElementT temp;
        for (i = 0; i < k; ++i) {
            if (tau.cell(i) == 0) {
                for (j = 0; j < i+1; ++j) {
                    t.cell(i, j) = 0;
                }
                continue;
            }
            if (i > 0) {
                for (j = 0; j < i; ++j) {
                    temp = v.cell(j, i);
                    for (l = i+1; l < m; ++l) {
                        temp += v.cell(j, l) * v.cell(i, l);
                    }
                    t.cell(i, j) = -tau.cell(i) * temp;
                }
                for (j = 0; j < i; ++j) {
                    temp = 0;
                    for (l = j; l < i; ++l) {
                        temp += t.cell(l, j) * t.cell(i, l);
                    }
                    t.cell(i, j) = temp;
                }
            }
            t.cell(i, i) = tau.cell(i);
        }
    }
}

// in-place left multiply by block reflector: C = (I - V*T*V') * C.
// pass UPFLAG=1 if T is upper-triangular, 0 otherwise.
// similar to DLARFB
transform QRRMult
from UPFLAG, V[b,m], T[b,b]
to C[n,m]
{
    to (C c) from (UPFLAG upFlag, V v, T t)
    {
        MatrixRegion2D w, c1, c2;
        ConstMatrixRegion2D v1, v2;

        // allocate work array
        w = MatrixRegion2D::allocate(n,b);

        // aliases
        c1 = c.region(0,0,n,b);
        c2 = c.region(0,b,n,m);
        v1 = v.region(0,0,b,b);
        v2 = v.region(0,b,b,m);

        // STEP 1: Compute w = v' * c = (v1' * c1 + v2' * c2)
        //   a) w = v1' * c1
        TriMatrixMultiply(w, 1, 1, v1.transposed(), c1);
        //   b) w += v2' * c2
        MatrixMultiplyAdd(w, 1.0, v2.transposed(), c2, 1.0);

        // STEP 2: Compute w = t * w
        TriMatrixMultiplyInPlace(w, upFlag, 0, t);

        // STEP 3: Compute c = c - v * w
        //   a) c1 = c1 - v1 * w
        TriMatrixMultiplyAdd(c1, 0, 1, -1.0, v1, w, 1.0);
        //   b) c2 = c2 - v2 * w
        MatrixMultiplyAdd(c2, -1.0, v2, w, 1.0);
    }
}

// tunable blocked version of QRR
transform QRRBlocked
to A[n,m], TAU[n]
tunable blockSize
{
    // right-looking
    to (A a, TAU tau) from ()
    {
        //base case
        if (blockSize < 1 || blockSize >= MIN(m,n)) {
            QRRBase(a, tau);
            return;
        }

        MatrixRegion1D tau1, tau2;
        MatrixRegion2D a1, a2, a22, t;
        t = MatrixRegion2D::allocate(blockSize, blockSize);

        a1  = a.region(0, 0, blockSize, m);
        a2  = a.region(blockSize, 0, n, m);
        a22 = a.region(blockSize, blockSize, n, m);

        tau1 = tau.region(0, blockSize);
        tau2 = tau.region(blockSize, n);

        // compute QR of left block
        QRRBase(a1, tau1);

        // compute triangular factor for block reflector
        QRRTriFact(t, a1, tau1);

        // apply transposed block reflector to trailing matrix
        QRRMult(a2, 0, a1, t.transposed());

        // factor trailing matrix
        QRRBlocked(a22, tau2);
    }

    // left-looking
    to (A a, TAU tau) from ()
    {
        //base case
        if (blockSize < 1 || blockSize >= MIN(m,n)) {
            QRRBase(a, tau);
            return;
        }

        IndexT p = MIN(m,n), i0, i1, j0, j1;
        MatrixRegion1D tau1;
        MatrixRegion2D a1, a2, t, t1;

        // space for all of the triangular factors (stacked vertically)
        t = MatrixRegion2D::allocate(blockSize, p);

        for (i0 = 0; i0 < p; i0 += blockSize) {

            i1 = MIN(i0 + blockSize, p);

            // lazy update of current column block
            for (j0 = 0; j0 < i0; j0 += blockSize) {
                j1 = j0 + blockSize;
                a1  = a.region(j0, j0, j1, m);
                a2  = a.region(i0, j0, i1, m);
                t1 = t.region(0, j0, j1-j0, j1);

                // apply transposed block reflector to current column block
                QRRMult(a2, 0, a1, t1.transposed());
            }

            // compute QR of current column block
            a1 = a.region(i0, i0, i1, m);
            tau1 = tau.region(i0, i1);
            QRRBase(a1, tau1);

            // compute triangular factor for block reflector
            if (i1 < p || n > m) {
                t1 = t.region(0, i0, i1-i0, i1);
                QRRTriFact(t1, a1, tau1);
            }
        }

        if (n > m) {
            // apply transposed block reflector to trailing matrix
            for (j0 = 0; j0 < m; j0 += blockSize) {
                j1 = MIN(j0 + blockSize, m);
                a1  = a.region(j0, j0, j1, m);
                a2  = a.region(m , j0, n , m);
                t1 = t.region(0, j0, j1-j0, j1);
                QRRMult(a2, 0, a1, t1.transposed());
            }

            // set trailing tau array
            Init1D(tau.region(m, n), 0);
        }
    }

    // call LAPACK
    to (A a, TAU tau) from ()
    {
        QRRBlockedLAPACK(a, tau, a);
    }
}

// tunable recursive version of QRR
// recursively divide A into two parts, and do QR on each part sequentially
transform QRRRecursive
to A[n,m], TAU[n]
tunable blockSize
{
    to (A a, TAU tau) from ()
    {
        // base case
        if (blockSize < 1 || blockSize >= MIN(m,n)) {
            QRRBlocked(a, tau);
            return;
        }

        IndexT b = MIN(m,n) / 2;
        MatrixRegion1D tau1, tau2;
        MatrixRegion2D a1, a2, a22, t;
        t = MatrixRegion2D::allocate(b, b);

        a1  = a.region(0, 0, b, m);
        a2  = a.region(b, 0, n, m);
        a22 = a.region(b, b, n, m);

        tau1 = tau.region(0, b);
        tau2 = tau.region(b, n);

        // compute QR of left half
        QRRRecursive(a1, tau1);

        // compute triangular factor for block reflector
        QRRTriFact(t, a1, tau1);

        // apply transposed block reflector to trailing matrix
        QRRMult(a2, 0, a1, t.transposed());

        // factor trailing matrix
        QRRRecursive(a22, tau2);
    }
}

// Perform an in-place LAPACK-style QR using Householder reflections.
//
// On entry, A contains the matrix to be factored; on exit, the upper triangular
// part of A contains R, and the lower triangular part (along with TAU) contains
// a representation of the k elementary reflectors whose product is Q.
//
// See LAPACK documentation for DGEQRF for more details.
transform QRR
to A[n,m], TAU[n]
{
    // call recursive version
    to (A a, TAU tau) from ()
    {
        QRRRecursive(a, tau);
    }

    // call blocked version
    to (A a, TAU tau) from ()
    {
        QRRBlocked(a, tau);
    }

    // call base version
    to (A a, TAU tau) from ()
    {
        QRRBase(a, tau);
    }
}

// On entry, Q contains the matrix to be factored; on exit, it contains Q.
transform QRInPlace
to Q[n,m], R[n,m]
{
    // Householder
    to (Q q, R r) from ()
    {
        MatrixRegion1D tau = MatrixRegion1D::allocate(n);
        QRR(q, tau);
        QRRConvert(q, r, tau);
    }
}

transform QR
from A[n,m]
to Q[n,m], R[n,m]
{
    to (Q q, R r)
    from (A a)
    {
        Copy2D(q, a);
        QRInPlace(q, r);
    }
}

#endif // QR_PBCC
